source(output(
		AEDAT as date,
		ANGDT as date,
		BEDAT as date,
		BSART as string,
		BSTYP as string,
		BUKRS as string,
		DPAMT as decimal(11,2),
		DPDAT as date,
		DPPCT as decimal(5,2),
		DPTYP as string,
		EBELN as string,
		EKGRP as string,
		EKKO_POHDR_KEY as string,
		EKORG as string,
		ERNAM as string,
		FRGRL as string,
		INCO1 as string,
		INCO2 as string,
		KNUMV as string,
		LIFNR as string,
		WAERS as string,
		WKURS as decimal(9,5),
		ZBD1T as integer,
		ZTERM as string
	),
	allowSchemaDrift: true,
	validateSchema: false,
	ignoreNoFilesFound: false,
	batchSize: 5000,
	isolationLevel: 'READ_UNCOMMITTED',
	format: 'table') ~> EKKO
source(output(
		AEDAT as date,
		ANFNR as string,
		ANFPS as integer,
		BANFN as string,
		BEDNR as string,
		BNFPO as integer,
		BRTWR as decimal(13,2),
		BUKRS as string,
		EBELN as string,
		EBELP as integer,
		EKPO_POLN_KEY as string,
		ELIKZ as string,
		KNTTP as string,
		LEWED as date,
		LOEKZ as string,
		MATKL as string,
		MATNR as string,
		MEINS as string,
		MENGE as decimal(13,3),
		NETPR as decimal(11,2),
		NETWR as decimal(13,2),
		PEINH as integer,
		PRIO_URG as integer,
		PSTYP as string,
		STATU as string,
		TXZ01 as string,
		WERKS as string,
		LGORT as string
	),
	allowSchemaDrift: true,
	validateSchema: false,
	ignoreNoFilesFound: false,
	batchSize: 5000,
	isolationLevel: 'READ_UNCOMMITTED',
	format: 'table') ~> EKPO
source(output(
		BANFN as string,
		BNFPO as integer,
		EBELN as string,
		EBELP as integer,
		EINDT as date,
		EKET_SCHLN_KEY as string,
		SLFDT as date,
		LOAD_DATETIME as timestamp
	),
	allowSchemaDrift: true,
	validateSchema: false,
	ignoreNoFilesFound: false,
	batchSize: 5000,
	isolationLevel: 'READ_UNCOMMITTED',
	format: 'table') ~> EKET
source(output(
		BELNR as string,
		BEWTP as string,
		BLDAT as date,
		BUDAT as date,
		BUZEI as integer,
		BWART as string,
		DMBTR as decimal(15,3),
		EBELN as string,
		EBELP as integer,
		ERNAM as string,
		GJAHR as integer,
		MENGE as decimal(15,3),
		SHKZG as string,
		WAERS as string,
		WRBTR as decimal(15,3),
		LFBNR as string,
		LFGJA as string,
		LFPOS as string
	),
	allowSchemaDrift: true,
	validateSchema: false,
	ignoreNoFilesFound: false,
	batchSize: 5000,
	isolationLevel: 'READ_UNCOMMITTED',
	format: 'table') ~> EKBE
source(output(
		BELNR as string,
		BEWTP as string,
		BLDAT as date,
		BUDAT as date,
		BUZEI as integer,
		BWART as string,
		DMBTR as decimal(15,3),
		EBELN as string,
		EBELP as integer,
		ERNAM as string,
		GJAHR as integer,
		MENGE as decimal(15,3),
		SHKZG as string,
		WAERS as string,
		WRBTR as decimal(15,3),
		LFBNR as string,
		LFGJA as string,
		LFPOS as string
	),
	allowSchemaDrift: true,
	validateSchema: false,
	ignoreNoFilesFound: false,
	batchSize: 5000,
	isolationLevel: 'READ_UNCOMMITTED',
	format: 'table') ~> EKBEInvoice
source(output(
		ARKTX as string,
		LFIMG as decimal(13,3),
		MATKL as string,
		MATNR as string,
		NETWR as decimal(15,2),
		POSNR as integer,
		VBELN as string,
		VGBEL as string,
		VGPOS as integer
	),
	allowSchemaDrift: true,
	validateSchema: false,
	ignoreNoFilesFound: false,
	batchSize: 5000,
	isolationLevel: 'READ_UNCOMMITTED',
	format: 'table') ~> LIPSPROC
source(output(
		AFNAM as string,
		BADAT as date,
		BANFN as string,
		BEDNR as string,
		BLCKD as string,
		BNFPO as integer,
		BSART as string,
		BSMNG as decimal(13,3),
		EBELN as string,
		EBELP as integer,
		EKGRP as string,
		EKORG as string,
		ERDAT as date,
		ERNAM as string,
		FRGKZ as string,
		FRGST as string,
		FRGZU as string,
		KNTTP as string,
		LFDAT as date,
		LGORT as string,
		LOAD_DATETIME as date,
		LOEKZ as string,
		MATKL as string,
		MATNR as string,
		MEINS as string,
		MENGE as decimal(13,3),
		PEINH as integer,
		PREIS as decimal(11,2),
		PRIO_URG as integer,
		PSTYP as string,
		RLWRT as decimal(15,2),
		STATU as string,
		TXZ01 as string,
		WAERS as string,
		WERKS as string
	),
	allowSchemaDrift: true,
	validateSchema: false,
	ignoreNoFilesFound: false,
	batchSize: 5000,
	isolationLevel: 'READ_UNCOMMITTED',
	format: 'table') ~> EBAN
source(output(
		{PR No} as string,
		{PR Ln} as string,
		{PR Release Date} as date
	),
	allowSchemaDrift: true,
	validateSchema: false,
	ignoreNoFilesFound: false,
	batchSize: 5000,
	isolationLevel: 'READ_UNCOMMITTED',
	format: 'table') ~> PRRELEASEDATE
source(output(
		{PO No} as string,
		{PO Release Date} as date,
		SKEY as long
	),
	allowSchemaDrift: true,
	validateSchema: false,
	ignoreNoFilesFound: false,
	batchSize: 5000,
	isolationLevel: 'READ_UNCOMMITTED',
	format: 'table') ~> PORELEASEDATE
SelectRenameColumnsEKKO, SelectRenameColumnsEKPO join(EBELN == {PO No},
	joinType:'inner',
	broadcast: 'auto')~> EKKOEKPOJN
EKPO select(mapColumn(
		{PO Changed Date} = AEDAT,
		{PO RFQ No} = ANFNR,
		{PO RFQ Ln} = ANFPS,
		{PO Tracking Number} = BEDNR,
		{PO Gross Value} = BRTWR,
		{PO No} = EBELN,
		{PO Ln} = EBELP,
		{PO Inbound Complete} = ELIKZ,
		{PO Latest GR Date} = LEWED,
		{PO Deletion Ind} = LOEKZ,
		{PO UOM} = MEINS,
		{PO Qty} = MENGE,
		{PO Net Price} = NETPR,
		{PO Net Order Value} = NETWR,
		{PO Price Unit} = PEINH,
		{PO Item Category} = PSTYP,
		{PO Status} = STATU,
		{PO Desc} = TXZ01
	),
	skipDuplicateMapInputs: true,
	skipDuplicateMapOutputs: true) ~> SelectRenameColumnsEKPO
EKKO select(mapColumn(
		{PO Created Date} = AEDAT,
		{PO Document Date} = BEDAT,
		{PO Document Type} = BSART,
		{PO Doc Category} = BSTYP,
		{PO Downpayment Amount} = DPAMT,
		{PO Downpayment Due Date} = DPDAT,
		{PO Downpayment Perc} = DPPCT,
		{PO Downpayment Type} = DPTYP,
		EBELN,
		{PO Purchasing Org} = EKORG,
		{PO Created By} = ERNAM,
		{PO Incoterms1} = INCO1,
		{PO Incoterms2} = INCO2,
		{PO Currency} = WAERS,
		{PO Exchange Rate} = WKURS,
		{PO Payment Ind} = ZBD1T,
		{PO Payment Terms} = ZTERM
	),
	skipDuplicateMapInputs: true,
	skipDuplicateMapOutputs: true) ~> SelectRenameColumnsEKKO
EKET select(mapColumn(
		EBELN,
		EBELP,
		{PO Scheduled Date} = EINDT,
		{PO Statistical Delivery Date} = SLFDT
	),
	skipDuplicateMapInputs: true,
	skipDuplicateMapOutputs: true) ~> SelectRenameColumnsEKET
EKKOEKPOJN, SelectRenameColumnsEKET join({PO No} == SelectRenameColumnsEKET@EBELN
	&& {PO Ln} == EBELP,
	joinType:'inner',
	broadcast: 'auto')~> EKETJN
EKETJN select(mapColumn(
		{PO Created Date},
		{PO Document Date},
		{PO Document Type},
		{PO Doc Category},
		{PO Downpayment Amount},
		{PO Downpayment Due Date},
		{PO Downpayment Perc},
		{PO Downpayment Type},
		{PO Purchasing Org},
		{PO Created By},
		{PO Incoterms1},
		{PO Incoterms2},
		{PO Currency},
		{PO Exchange Rate},
		{PO Payment Ind},
		{PO Payment Terms},
		{PO Changed Date},
		{PO RFQ No},
		{PO RFQ Ln},
		{PO Tracking Number},
		{PO Gross Value},
		{PO No},
		{PO Ln},
		{PO Inbound Complete},
		{PO Latest GR Date},
		{PO Deletion Ind},
		{PO UOM},
		{PO Qty},
		{PO Net Price},
		{PO Net Order Value},
		{PO Price Unit},
		{PO Item Category},
		{PO Status},
		{PO Desc},
		{PO Scheduled Date},
		{PO Statistical Delivery Date}
	),
	skipDuplicateMapInputs: true,
	skipDuplicateMapOutputs: true) ~> SelectColumns
SelectColumns derive({PO Doc Category} = case({PO Doc Category}=="A","RFQ",{PO Doc Category}=="F","PO",{PO Doc Category}=="W","Created via AT",{PO Doc Category}=="K","Contract",{PO Doc Category}=="L","Schd Agrmnt",{PO Doc Category}),
		{PO Status} = case({PO Status}=="A","Quotation Exists",{PO Status}=="V","Created via SD",{PO Status}=="W","Created via AT",{PO Status}=="F","Created via PO",isNull({PO Status}),"No Quotation Exists",{PO Status}),
		{PO Inbound Complete} = iif({PO Inbound Complete}=="X","Yes","No"),
		{PO Item Category} = iif({PO Item Category}=="9","Service", "Material"),
		{PO Deletion Ind} = iif({PO Deletion Ind}=="X","Deleted","Active"),
		{PO No} = ltrim({PO No},"0"),
		{PO Ln} = toString({PO Ln})) ~> ReplaceValues
SelectRenameColumns filter(BEWTP=="E") ~> FilterBEWTP
EKBE select(mapColumn(
		BEWTP,
		EBELN,
		EBELP,
		{GR Qty} = MENGE,
		SHKZG,
		{GR Value} = WRBTR
	),
	skipDuplicateMapInputs: true,
	skipDuplicateMapOutputs: true) ~> SelectRenameColumns
FilterBEWTP derive({GR Qty} = iif(SHKZG=="H", {GR Qty}*-1,{GR Qty}),
		EBELP = toString({EBELP})) ~> DerivedColumn1
DerivedColumn1 aggregate(groupBy(EBELN,
		EBELP),
	{GR Qty} = sum({GR Qty})) ~> GroupByGRQuantity
POReleaseDateJN, GroupByGRQuantity join(ReplaceValues@{PO No} == EBELN
	&& {PO Ln} == EBELP,
	joinType:'left',
	broadcast: 'auto')~> POGRJN
EKBEInvoice select(mapColumn(
		BEWTP,
		EBELN,
		EBELP,
		{Invoice Qty} = MENGE,
		SHKZG,
		{Invoice Value} = WRBTR
	),
	skipDuplicateMapInputs: true,
	skipDuplicateMapOutputs: true) ~> SelectRenameColumns2
SelectRenameColumns2 filter(BEWTP=="Q") ~> FilterBETWP
FilterBETWP derive({Invoice Qty} = iif(SHKZG=="H",{Invoice Qty}*-1,{Invoice Qty}),
		{Invoice Value} = iif(SHKZG=="H", {Invoice Value}*-1,{Invoice Value}),
		EBELP = toString(EBELP)) ~> DerivedColumn2
DerivedColumn2 aggregate(groupBy(EBELN,
		EBELP),
	{Invoice Qty} = sum({Invoice Qty}),
		{Invoice Value} = sum({Invoice Value})) ~> GroupByInvoiceQtyValue
POGRJN, GroupByInvoiceQtyValue join(ReplaceValues@{PO No} == GroupByInvoiceQtyValue@EBELN
	&& {PO Ln} == GroupByInvoiceQtyValue@EBELP,
	joinType:'left',
	broadcast: 'auto')~> POInvoiceJN
LIPSPROC select(mapColumn(
		{Inbound Qty} = LFIMG,
		VGBEL,
		VGPOS
	),
	skipDuplicateMapInputs: true,
	skipDuplicateMapOutputs: true) ~> SelectRenameColumns3
SelectRenameColumns3 derive(VGPOS = toString({VGPOS})) ~> DerivedColumn3
DerivedColumn3 aggregate(groupBy(VGBEL,
		VGPOS),
	{Inbound Qty} = sum({Inbound Qty})) ~> GroupByInboundQty
POInvoiceJN, GroupByInboundQty join(ReplaceValues@{PO No} == VGBEL
	&& {PO Ln} == VGPOS,
	joinType:'inner',
	broadcast: 'auto')~> POInboundJN
EBAN select(mapColumn(
		BANFN,
		BNFPO,
		EBELN,
		EBELP,
		{PR Net Order Value} = RLWRT
	),
	skipDuplicateMapInputs: true,
	skipDuplicateMapOutputs: true) ~> SelectRenameColumns4
SelectRenameColumns4 derive(BNFPO = toString(BNFPO),
		EBELP = toString(EBELP),
		BANFN = ltrim(BANFN,"0")) ~> DerivedColumn4
DerivedColumn4, PRRELEASEDATE join(BANFN == {PR No}
	&& BNFPO == {PR Ln},
	joinType:'left',
	broadcast: 'auto')~> JoinPRReleaseDate
POInboundJN, JoinPRReleaseDate join(ReplaceValues@{PO No} == SelectRenameColumns4@EBELN
	&& {PO Ln} == DerivedColumn4@EBELP,
	joinType:'left',
	broadcast: 'auto')~> POPRreleaseDateJN
POPRreleaseDateJN derive({PR to PO Cycle Time} = {PO Created Date}-{PR Release Date},
		{Yet to Receive Qty} = {PO Qty}-{GR Qty},
		{In Transit Qty} = {Inbound Qty}-{GR Qty},
		{PO CKey} = iifNull(ltrim(concat(ReplaceValues@{PO No}, {PO Ln}),"0"),"-1",ltrim(concat(ReplaceValues@{PO No}, {PO Ln}),"0")),
		{Purchase Price Variance} = {PO Net Order Value}-{PR Net Order Value},
		{Invoice Pending Amount} = {PO Gross Value}-{Invoice Value},
		{Yet to be Shipped Qty} = {PO Qty}-{Inbound Qty}) ~> Measures
Measures select(mapColumn(
		{PO Created Date},
		{PO Document Date},
		{PO Document Type},
		{PO Doc Category},
		{PO Downpayment Amount},
		{PO Downpayment Due Date},
		{PO Downpayment Perc},
		{PO Downpayment Type},
		{PO Purchasing Org},
		{PO Created By},
		{PO Incoterms1},
		{PO Incoterms2},
		{PO Currency},
		{PO Exchange Rate},
		{PO Payment Ind},
		{PO Payment Terms},
		{PO Changed Date},
		{PO RFQ No},
		{PO RFQ Ln},
		{PO Tracking Number},
		{PO Gross Value},
		{PO No} = ReplaceValues@{PO No},
		{PO Ln},
		{PO Inbound Complete},
		{PO Latest GR Date},
		{PO Deletion Ind},
		{PO UOM},
		{PO Qty},
		{PO Net Price},
		{PO Net Order Value},
		{PO Price Unit},
		{PO Item Category},
		{PO Status},
		{PO Desc},
		{PO Scheduled Date},
		{PO Statistical Delivery Date},
		{GR Qty},
		{Invoice Qty},
		{Invoice Value},
		{Inbound Qty},
		{PR Net Order Value},
		{PR No},
		{PR Ln},
		{PR Release Date},
		{PR to PO Cycle Time},
		{Yet to Receive Qty},
		{In Transit Qty},
		{Purchase Price Variance},
		{Invoice Pending Amount},
		{Yet to be Shipped Qty},
		{PO Release Date},
		{PO CKey}
	),
	skipDuplicateMapInputs: true,
	skipDuplicateMapOutputs: true) ~> SelectRequiredColumns
SelectRequiredColumns keyGenerate(output({PO SKey} as long),
	startAt: 1L) ~> SurrogateKey
Filter1, PORELEASEDATE join(ReplaceValues@{PO No} == PORELEASEDATE@{PO No},
	joinType:'left',
	broadcast: 'auto')~> POReleaseDateJN
ReplaceValues filter({PO Doc Category}=="PO") ~> Filter1
SurrogateKey sink(input(
		{PO Created Date} as date,
		{PO Document Date} as date,
		{PO Document Type} as string,
		{PO Doc Category} as string,
		{PO Downpayment Amount} as decimal(11,2),
		{PO Downpayment Due Date} as date,
		{PO Downpayment Perc} as decimal(5,2),
		{PO Downpayment Type} as string,
		{PO Purchasing Org} as string,
		{PO Created By} as string,
		{PO Incoterms1} as string,
		{PO Incoterms2} as string,
		{PO Currency} as string,
		{PO Exchange Rate} as decimal(9,5),
		{PO Payment Ind} as integer,
		{PO Payment Terms} as string,
		{PO Changed Date} as date,
		{PO RFQ No} as string,
		{PO RFQ Ln} as integer,
		{PO Tracking Number} as string,
		{PO Gross Value} as decimal(13,2),
		{PO No} as string,
		{PO Ln} as string,
		{PO Inbound Complete} as string,
		{PO Latest GR Date} as date,
		{PO Deletion Ind} as string,
		{PO UOM} as string,
		{PO Qty} as decimal(13,3),
		{PO Net Price} as decimal(11,2),
		{PO Net Value} as decimal(13,2),
		{PO Price Unit} as integer,
		{PO Item Category} as string,
		{PO Status} as string,
		{PO Desc} as string,
		{PO Scheduled Date} as date,
		{PO Statistical Delivery Date} as date,
		{GR Qty} as decimal(34,3),
		{Invoice Qty} as decimal(34,3),
		{Invoice Value} as decimal(34,2),
		{Inbound Qty} as decimal(23,3),
		{PR Net Order Value} as decimal(15,2),
		{PR No} as string,
		{PR Ln} as string,
		{PR Release Date} as date,
		{PR to PO Cycle Time} as integer,
		{Yet to Receive Qty} as decimal(35,3),
		{In Transit Qty} as decimal(35,3),
		{Purchase Price Variance} as decimal(16,2),
		{Invoice Pending Amount} as decimal(35,2),
		{Yet to be Shipped Qty} as decimal(24,3),
		{PO Release Date} as date,
		{PO CKey} as string,
		{PO SKey} as long
	),
	allowSchemaDrift: true,
	validateSchema: false,
	deletable:false,
	insertable:true,
	updateable:false,
	upsertable:false,
	recreate:true,
	format: 'table',
	batchSize: 5000,
	postSQLs:['insert into [dbo].[F_PURCHASEORDER]([PO CKey],[PO SKey]) values(\'-1\',-1)'],
	skipDuplicateMapInputs: true,
	skipDuplicateMapOutputs: true,
	errorHandlingOption: 'stopOnFirstError') ~> FPURCHASEORDER